/Users/simon/miniconda3/envs/algo_trading/bin/python /Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/test_run_models.py
['BTCUSD_vwap', 'ETHUSD_vwap', 'USDTUSD_vwap', 'XRPUSD_vwap', 'ADAUSD_vwap', 'DOGEUSD_vwap', 'LTCUSD_vwap', '5_YR', '7_YR', '10_YR', '20_YR', '4_Wk_Bank_Discount_Rate', '13_Wk_Bank_Discount_Rate', '52_Wk_Bank_Discount_Rate', 'tips', 'uk_20y_nif', 'uk_10y_nif', 'uk_5y_nif', 'uk_bank_rate', 'EM_HY', 'US_Corp', 'vix', 'usd_nominal', 'usd_real', 'usd_euro', 'gold_london', 'silver_london', 'ma7', 'ma21', '26ema', '12ema', 'MACD', '20sd', 'upper_band', 'lower_band', 'ema', 'RSI', 'absolute_3_comp', 'angle_3_comp', 'absolute_6_comp', 'angle_6_comp', 'absolute_9_comp', 'angle_9_comp']
number of features: 43
X_Train_val (1288, 43), y_train_val (1258, 1)
X_test(522, 30, 43), y_test (522, 1)
/Users/simon/.local/lib/python3.10/site-packages/numpy/lib/format.py:366: UserWarning: metadata on a dtype may be saved or ignored, but will raise if saved when read. Use another form of storage.
  d['descr'] = dtype_to_descr(array.dtype)
['BTCUSD_vwap', 'ETHUSD_vwap', 'USDTUSD_vwap', 'XRPUSD_vwap', 'ADAUSD_vwap', 'DOGEUSD_vwap', 'LTCUSD_vwap', '5_YR', '7_YR', '10_YR', '20_YR', '4_Wk_Bank_Discount_Rate', '13_Wk_Bank_Discount_Rate', '52_Wk_Bank_Discount_Rate', 'tips', 'uk_20y_nif', 'uk_10y_nif', 'uk_5y_nif', 'uk_bank_rate', 'EM_HY', 'US_Corp', 'vix', 'usd_nominal', 'usd_real', 'usd_euro', 'gold_london', 'silver_london', 'ma7', 'ma21', '26ema', '12ema', 'MACD', '20sd', 'upper_band', 'lower_band', 'ema', 'RSI', 'absolute_3_comp', 'angle_3_comp', 'absolute_6_comp', 'angle_6_comp', 'absolute_9_comp', 'angle_9_comp']
number of features: 43
X_Train(1193, 30, 43), y_train (1193, 1)
X_val(495, 30, 43), y_val (495, 1)
X_test(62, 30, 43), y_test (62, 1)
/Users/simon/.local/lib/python3.10/site-packages/numpy/lib/format.py:366: UserWarning: metadata on a dtype may be saved or ignored, but will raise if saved when read. Use another form of storage.
  d['descr'] = dtype_to_descr(array.dtype)
input_dim: 3, feature_size: 43, output_dim: 1
Metal device set to: Apple M2 Max

systemMemory: 32.00 GB
maxCacheSize: 10.67 GB

2023-05-01 17:30:22.287341: W tensorflow/core/platform/profile_utils/cpu_utils.cc:128] Failed to get CPU frequency: 0 Hz
Epoch 1/50
10/10 - 2s - loss: 0.8066 - val_loss: 0.2083 - 2s/epoch - 156ms/step
Epoch 2/50
10/10 - 0s - loss: 0.3043 - val_loss: 0.1499 - 49ms/epoch - 5ms/step
Epoch 3/50
10/10 - 0s - loss: 0.0787 - val_loss: 0.1301 - 51ms/epoch - 5ms/step
Epoch 4/50
10/10 - 0s - loss: 0.0123 - val_loss: 0.1240 - 51ms/epoch - 5ms/step
Epoch 5/50
10/10 - 0s - loss: 0.0108 - val_loss: 0.1184 - 54ms/epoch - 5ms/step
Epoch 6/50
10/10 - 0s - loss: 0.0113 - val_loss: 0.1144 - 56ms/epoch - 6ms/step
Epoch 7/50
10/10 - 0s - loss: 0.0072 - val_loss: 0.1126 - 57ms/epoch - 6ms/step
Epoch 8/50
10/10 - 0s - loss: 0.0055 - val_loss: 0.1100 - 58ms/epoch - 6ms/step
Epoch 9/50
10/10 - 0s - loss: 0.0052 - val_loss: 0.1057 - 57ms/epoch - 6ms/step
Epoch 10/50
10/10 - 0s - loss: 0.0048 - val_loss: 0.1012 - 56ms/epoch - 6ms/step
Epoch 11/50
10/10 - 0s - loss: 0.0045 - val_loss: 0.0973 - 55ms/epoch - 6ms/step
Epoch 12/50
10/10 - 0s - loss: 0.0043 - val_loss: 0.0944 - 54ms/epoch - 5ms/step
Epoch 13/50
10/10 - 0s - loss: 0.0041 - val_loss: 0.0922 - 56ms/epoch - 6ms/step
Epoch 14/50
10/10 - 0s - loss: 0.0039 - val_loss: 0.0902 - 59ms/epoch - 6ms/step
Epoch 15/50
10/10 - 0s - loss: 0.0038 - val_loss: 0.0885 - 57ms/epoch - 6ms/step
Epoch 16/50
10/10 - 0s - loss: 0.0037 - val_loss: 0.0869 - 54ms/epoch - 5ms/step
Epoch 17/50
10/10 - 0s - loss: 0.0036 - val_loss: 0.0856 - 57ms/epoch - 6ms/step
Epoch 18/50
10/10 - 0s - loss: 0.0035 - val_loss: 0.0844 - 58ms/epoch - 6ms/step
Epoch 19/50
10/10 - 0s - loss: 0.0034 - val_loss: 0.0834 - 58ms/epoch - 6ms/step
Epoch 20/50
10/10 - 0s - loss: 0.0033 - val_loss: 0.0824 - 57ms/epoch - 6ms/step
Epoch 21/50
10/10 - 0s - loss: 0.0032 - val_loss: 0.0816 - 57ms/epoch - 6ms/step
Epoch 22/50
10/10 - 0s - loss: 0.0032 - val_loss: 0.0809 - 59ms/epoch - 6ms/step
Epoch 23/50
10/10 - 0s - loss: 0.0031 - val_loss: 0.0802 - 57ms/epoch - 6ms/step
Epoch 24/50
10/10 - 0s - loss: 0.0030 - val_loss: 0.0796 - 55ms/epoch - 5ms/step
Epoch 25/50
10/10 - 0s - loss: 0.0030 - val_loss: 0.0790 - 55ms/epoch - 5ms/step
Epoch 26/50
10/10 - 0s - loss: 0.0029 - val_loss: 0.0786 - 58ms/epoch - 6ms/step
Epoch 27/50
10/10 - 0s - loss: 0.0029 - val_loss: 0.0781 - 57ms/epoch - 6ms/step
Epoch 28/50
10/10 - 0s - loss: 0.0028 - val_loss: 0.0777 - 54ms/epoch - 5ms/step
Epoch 29/50
10/10 - 0s - loss: 0.0028 - val_loss: 0.0774 - 54ms/epoch - 5ms/step
Epoch 30/50
10/10 - 0s - loss: 0.0027 - val_loss: 0.0770 - 56ms/epoch - 6ms/step
Epoch 31/50
10/10 - 0s - loss: 0.0027 - val_loss: 0.0768 - 57ms/epoch - 6ms/step
Epoch 32/50
10/10 - 0s - loss: 0.0026 - val_loss: 0.0765 - 55ms/epoch - 5ms/step
Epoch 33/50
10/10 - 0s - loss: 0.0026 - val_loss: 0.0763 - 54ms/epoch - 5ms/step
Epoch 34/50
10/10 - 0s - loss: 0.0026 - val_loss: 0.0761 - 58ms/epoch - 6ms/step
Epoch 35/50
10/10 - 0s - loss: 0.0025 - val_loss: 0.0759 - 56ms/epoch - 6ms/step
Epoch 36/50
10/10 - 0s - loss: 0.0025 - val_loss: 0.0758 - 55ms/epoch - 6ms/step
Epoch 37/50
10/10 - 0s - loss: 0.0025 - val_loss: 0.0756 - 55ms/epoch - 6ms/step
Epoch 38/50
10/10 - 0s - loss: 0.0024 - val_loss: 0.0755 - 57ms/epoch - 6ms/step
Epoch 39/50
10/10 - 0s - loss: 0.0024 - val_loss: 0.0754 - 57ms/epoch - 6ms/step
Epoch 40/50
10/10 - 0s - loss: 0.0024 - val_loss: 0.0753 - 58ms/epoch - 6ms/step
Epoch 41/50
10/10 - 0s - loss: 0.0023 - val_loss: 0.0753 - 69ms/epoch - 7ms/step
Epoch 42/50
10/10 - 0s - loss: 0.0023 - val_loss: 0.0752 - 74ms/epoch - 7ms/step
Epoch 43/50
10/10 - 0s - loss: 0.0023 - val_loss: 0.0752 - 58ms/epoch - 6ms/step
Epoch 44/50
10/10 - 0s - loss: 0.0023 - val_loss: 0.0751 - 52ms/epoch - 5ms/step
Epoch 45/50
10/10 - 0s - loss: 0.0022 - val_loss: 0.0751 - 55ms/epoch - 6ms/step
Epoch 46/50
10/10 - 0s - loss: 0.0022 - val_loss: 0.0751 - 57ms/epoch - 6ms/step
Epoch 47/50
10/10 - 0s - loss: 0.0022 - val_loss: 0.0750 - 57ms/epoch - 6ms/step
Epoch 48/50
10/10 - 0s - loss: 0.0022 - val_loss: 0.0750 - 56ms/epoch - 6ms/step
Epoch 49/50
10/10 - 0s - loss: 0.0021 - val_loss: 0.0750 - 56ms/epoch - 6ms/step
Epoch 50/50
10/10 - 0s - loss: 0.0021 - val_loss: 0.0750 - 57ms/epoch - 6ms/step
Model: "sequential"
_________________________________________________________________
 Layer (type)                Output Shape              Param #
=================================================================
 gru (GRU)                   (None, 3, 128)            66432

 gru_1 (GRU)                 (None, 64)                37248

 dense (Dense)               (None, 32)                2080

 dense_1 (Dense)             (None, 1)                 33

=================================================================
Total params: 105,793
Trainable params: 105,793
Non-trainable params: 0
_________________________________________________________________
None
Price Prediction Accuracy is 0.5163934426229508
----- Train_RMSE_GRU ----- 928.3822500437415
Price Prediction Accuracy is 0.5268199233716475
----- Val_RMSE_GRU ----- 2723.9321040612226
Price Prediction Accuracy is 0.5617977528089888
----- Test_RMSE_GRU ----- 1596.816214684816
input_dim: 3, feature_size: 43, output_dim: 1
/Users/simon/miniconda3/envs/algo_trading/lib/python3.10/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.
  super(Adam, self).__init__(name, **kwargs)
Epoch 1/50
20/20 - 2s - loss: 0.1071 - val_loss: 0.0318 - 2s/epoch - 101ms/step
Epoch 2/50
20/20 - 0s - loss: 0.2393 - val_loss: 0.1147 - 255ms/epoch - 13ms/step
Epoch 3/50
20/20 - 0s - loss: 0.2536 - val_loss: 1.6979 - 248ms/epoch - 12ms/step
Epoch 4/50
20/20 - 0s - loss: 0.8787 - val_loss: 0.6313 - 249ms/epoch - 12ms/step
Epoch 5/50
20/20 - 0s - loss: 0.3865 - val_loss: 0.8719 - 254ms/epoch - 13ms/step
Epoch 6/50
20/20 - 0s - loss: 0.2957 - val_loss: 0.3023 - 248ms/epoch - 12ms/step
Epoch 7/50
20/20 - 0s - loss: 0.0845 - val_loss: 0.1718 - 252ms/epoch - 13ms/step
Epoch 8/50
20/20 - 0s - loss: 0.0593 - val_loss: 0.0895 - 247ms/epoch - 12ms/step
Epoch 9/50
20/20 - 0s - loss: 0.0080 - val_loss: 0.0837 - 255ms/epoch - 13ms/step
Epoch 10/50
20/20 - 0s - loss: 0.0037 - val_loss: 0.0885 - 245ms/epoch - 12ms/step
Epoch 11/50
20/20 - 0s - loss: 0.0031 - val_loss: 0.0859 - 256ms/epoch - 13ms/step
Epoch 12/50
20/20 - 0s - loss: 0.0027 - val_loss: 0.0876 - 255ms/epoch - 13ms/step
Epoch 13/50
20/20 - 0s - loss: 0.0025 - val_loss: 0.0875 - 266ms/epoch - 13ms/step
Epoch 14/50
20/20 - 0s - loss: 0.0024 - val_loss: 0.0880 - 248ms/epoch - 12ms/step
Epoch 15/50
20/20 - 0s - loss: 0.0023 - val_loss: 0.0879 - 244ms/epoch - 12ms/step
Epoch 16/50
20/20 - 0s - loss: 0.0022 - val_loss: 0.0884 - 242ms/epoch - 12ms/step
Epoch 17/50
20/20 - 0s - loss: 0.0021 - val_loss: 0.0886 - 244ms/epoch - 12ms/step
Epoch 18/50
20/20 - 0s - loss: 0.0021 - val_loss: 0.0890 - 240ms/epoch - 12ms/step
Epoch 19/50
20/20 - 0s - loss: 0.0020 - val_loss: 0.0894 - 243ms/epoch - 12ms/step
Epoch 20/50
20/20 - 0s - loss: 0.0020 - val_loss: 0.0900 - 247ms/epoch - 12ms/step
Epoch 21/50
20/20 - 0s - loss: 0.0019 - val_loss: 0.0906 - 245ms/epoch - 12ms/step
Epoch 22/50
20/20 - 0s - loss: 0.0019 - val_loss: 0.0913 - 242ms/epoch - 12ms/step
Epoch 23/50
20/20 - 0s - loss: 0.0019 - val_loss: 0.0920 - 244ms/epoch - 12ms/step
Epoch 24/50
20/20 - 0s - loss: 0.0019 - val_loss: 0.0928 - 239ms/epoch - 12ms/step
Epoch 25/50
20/20 - 0s - loss: 0.0018 - val_loss: 0.0936 - 250ms/epoch - 13ms/step
Epoch 26/50
20/20 - 0s - loss: 0.0018 - val_loss: 0.0945 - 240ms/epoch - 12ms/step
Epoch 27/50
20/20 - 0s - loss: 0.0018 - val_loss: 0.0954 - 246ms/epoch - 12ms/step
Epoch 28/50
20/20 - 0s - loss: 0.0018 - val_loss: 0.0963 - 243ms/epoch - 12ms/step
Epoch 29/50
20/20 - 0s - loss: 0.0017 - val_loss: 0.0973 - 257ms/epoch - 13ms/step
Epoch 30/50
20/20 - 0s - loss: 0.0017 - val_loss: 0.0983 - 247ms/epoch - 12ms/step
Epoch 31/50
20/20 - 0s - loss: 0.0017 - val_loss: 0.0992 - 246ms/epoch - 12ms/step
Epoch 32/50
20/20 - 0s - loss: 0.0017 - val_loss: 0.1002 - 252ms/epoch - 13ms/step
Epoch 33/50
20/20 - 0s - loss: 0.0017 - val_loss: 0.1012 - 248ms/epoch - 12ms/step
Epoch 34/50
20/20 - 0s - loss: 0.0016 - val_loss: 0.1022 - 250ms/epoch - 13ms/step
Epoch 35/50
20/20 - 0s - loss: 0.0016 - val_loss: 0.1032 - 250ms/epoch - 12ms/step
Epoch 36/50
20/20 - 0s - loss: 0.0016 - val_loss: 0.1042 - 250ms/epoch - 12ms/step
Epoch 37/50
20/20 - 0s - loss: 0.0016 - val_loss: 0.1052 - 249ms/epoch - 12ms/step
Epoch 38/50
20/20 - 0s - loss: 0.0016 - val_loss: 0.1062 - 246ms/epoch - 12ms/step
Epoch 39/50
20/20 - 0s - loss: 0.0015 - val_loss: 0.1072 - 252ms/epoch - 13ms/step
Epoch 40/50
20/20 - 0s - loss: 0.0015 - val_loss: 0.1082 - 248ms/epoch - 12ms/step
Epoch 41/50
20/20 - 0s - loss: 0.0015 - val_loss: 0.1091 - 245ms/epoch - 12ms/step
Epoch 42/50
20/20 - 0s - loss: 0.0015 - val_loss: 0.1101 - 242ms/epoch - 12ms/step
Epoch 43/50
20/20 - 0s - loss: 0.0015 - val_loss: 0.1110 - 250ms/epoch - 12ms/step
Epoch 44/50
20/20 - 0s - loss: 0.0015 - val_loss: 0.1119 - 245ms/epoch - 12ms/step
Epoch 45/50
20/20 - 0s - loss: 0.0014 - val_loss: 0.1128 - 247ms/epoch - 12ms/step
Epoch 46/50
20/20 - 0s - loss: 0.0014 - val_loss: 0.1137 - 246ms/epoch - 12ms/step
Epoch 47/50
20/20 - 0s - loss: 0.0014 - val_loss: 0.1146 - 250ms/epoch - 12ms/step
Epoch 48/50
20/20 - 0s - loss: 0.0014 - val_loss: 0.1154 - 244ms/epoch - 12ms/step
Epoch 49/50
20/20 - 0s - loss: 0.0014 - val_loss: 0.1162 - 247ms/epoch - 12ms/step
Epoch 50/50
20/20 - 0s - loss: 0.0014 - val_loss: 0.1171 - 245ms/epoch - 12ms/step
Model: "sequential_1"
_________________________________________________________________
 Layer (type)                Output Shape              Param #
=================================================================
 bidirectional (Bidirectiona  (None, 256)              176128
 l)

 dense_2 (Dense)             (None, 64)                16448

 dense_3 (Dense)             (None, 1)                 65

=================================================================
Total params: 192,641
Trainable params: 192,641
Non-trainable params: 0
_________________________________________________________________
None
Price Prediction Accuracy is 0.5295081967213114
----- Train_RMSE_LSTM ----- 928.3774108175403
Price Prediction Accuracy is 0.5287356321839081
----- Val_RMSE_LSTM ----- 2723.9487623208493
Price Prediction Accuracy is 0.5168539325842697
----- Test_RMSE_LSTM ----- 1597.1552836511007
Running Basic Gan with the following configs: 3_1, 165, 128, 0.00016
output dimension is 1
WARNING:tensorflow:Layer gru_2 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_3 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_4 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
/Users/simon/miniconda3/envs/algo_trading/lib/python3.10/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.
  super(Adam, self).__init__(name, **kwargs)
/Users/simon/miniconda3/envs/algo_trading/lib/python3.10/site-packages/tensorflow/python/util/dispatch.py:1082: UserWarning: "`binary_crossentropy` received `from_logits=True`, but the `output` argument was produced by a sigmoid or softmax activation and thus does not represent logits. Was this intended?"
  return dispatch_target(*args, **kwargs)
epoch 15 d_loss 1.3858199 g_loss 0.69076663
epoch 30 d_loss 1.385598 g_loss 0.69312954
epoch 45 d_loss 1.3860301 g_loss 0.69420815
epoch 60 d_loss 1.386147 g_loss 0.69392914
epoch 75 d_loss 1.3862717 g_loss 0.69340324
epoch 90 d_loss 1.38623 g_loss 0.6930211
epoch 105 d_loss 1.3862109 g_loss 0.693587
epoch 120 d_loss 1.386312 g_loss 0.6933818
epoch 135 d_loss 1.3862016 g_loss 0.69216853
epoch 150 d_loss 1.386102 g_loss 0.6934671
epoch 165 d_loss 1.3863298 g_loss 0.6938717
WARNING:tensorflow:Compiled the loaded model, but the compiled metrics have yet to be built. `model.compile_metrics` will be empty until you train or evaluate the model.
pred_price length: 165, real price length: 1285
(1285,)
[-0.01015112 -0.00569626 -0.00410941 ...  0.0794308   0.07567835
  0.04938952]
price_df shape: (1285, 166)
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:35: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df['real_price'] = y_scaler.inverse_transform(real_price.reshape(-1, 1))
WARNING:tensorflow:Layer gru_2 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_3 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_4 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:No training configuration found in the save file, so the model was *not* compiled. Compile it manually.
Price Prediction Accuracy is 0.5063752276867031
WARNING:tensorflow:Layer gru_5 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_6 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
epoch 15 d_loss 9.3454485 g_loss -0.012388022
epoch 30 d_loss 8.515956 g_loss -0.034339838
epoch 45 d_loss 7.6232033 g_loss -0.06980256
epoch 60 d_loss 7.1196604 g_loss -0.20359589
epoch 75 d_loss 4.7801876 g_loss 0.5951953
epoch 90 d_loss 3.775785 g_loss -0.16276012
WARNING:tensorflow:Compiled the loaded model, but the compiled metrics have yet to be built. `model.compile_metrics` will be empty until you train or evaluate the model.
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_WGAN_GP.py:33: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

WARNING:tensorflow:Layer gru_5 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_6 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:No training configuration found in the save file, so the model was *not* compiled. Compile it manually.
Price Prediction Accuracy is 0.5318761384335154

Process finished with exit code 0
