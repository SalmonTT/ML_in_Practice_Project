/Users/simon/miniconda3/envs/algo_trading/bin/python /Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/test_run_models.py
['BTCUSD_vwap', 'ETHUSD_vwap', 'USDTUSD_vwap', 'XRPUSD_vwap', 'ADAUSD_vwap', 'DOGEUSD_vwap', 'LTCUSD_vwap', '5_YR', '7_YR', '10_YR', '20_YR', '4_Wk_Bank_Discount_Rate', '13_Wk_Bank_Discount_Rate', '52_Wk_Bank_Discount_Rate', 'tips', 'uk_20y_nif', 'uk_10y_nif', 'uk_5y_nif', 'uk_bank_rate', 'EM_HY', 'US_Corp', 'vix', 'usd_nominal', 'usd_real', 'usd_euro', 'gold_london', 'silver_london', 'ma7', 'ma21', '26ema', '12ema', 'MACD', '20sd', 'upper_band', 'lower_band', 'ema', 'RSI', 'absolute_3_comp', 'angle_3_comp', 'absolute_6_comp', 'angle_6_comp', 'absolute_9_comp', 'angle_9_comp']
number of features: 43
X_Train_val (1288, 43), y_train_val (1258, 1)
X_test(522, 30, 43), y_test (522, 1)
/Users/simon/.local/lib/python3.10/site-packages/numpy/lib/format.py:366: UserWarning: metadata on a dtype may be saved or ignored, but will raise if saved when read. Use another form of storage.
  d['descr'] = dtype_to_descr(array.dtype)
['BTCUSD_vwap', 'ETHUSD_vwap', 'USDTUSD_vwap', 'XRPUSD_vwap', 'ADAUSD_vwap', 'DOGEUSD_vwap', 'LTCUSD_vwap', '5_YR', '7_YR', '10_YR', '20_YR', '4_Wk_Bank_Discount_Rate', '13_Wk_Bank_Discount_Rate', '52_Wk_Bank_Discount_Rate', 'tips', 'uk_20y_nif', 'uk_10y_nif', 'uk_5y_nif', 'uk_bank_rate', 'EM_HY', 'US_Corp', 'vix', 'usd_nominal', 'usd_real', 'usd_euro', 'gold_london', 'silver_london', 'ma7', 'ma21', '26ema', '12ema', 'MACD', '20sd', 'upper_band', 'lower_band', 'ema', 'RSI', 'absolute_3_comp', 'angle_3_comp', 'absolute_6_comp', 'angle_6_comp', 'absolute_9_comp', 'angle_9_comp']
number of features: 43
X_Train(1193, 30, 43), y_train (1193, 1)
X_val(495, 30, 43), y_val (495, 1)
X_test(62, 30, 43), y_test (62, 1)
/Users/simon/.local/lib/python3.10/site-packages/numpy/lib/format.py:366: UserWarning: metadata on a dtype may be saved or ignored, but will raise if saved when read. Use another form of storage.
  d['descr'] = dtype_to_descr(array.dtype)
input_dim: 30, feature_size: 43, output_dim: 3
Metal device set to: Apple M2 Max

systemMemory: 32.00 GB
maxCacheSize: 10.67 GB

2023-05-01 16:43:15.929503: W tensorflow/core/platform/profile_utils/cpu_utils.cc:128] Failed to get CPU frequency: 0 Hz
Epoch 1/50
10/10 - 2s - loss: 0.5778 - val_loss: 0.3923 - 2s/epoch - 189ms/step
Epoch 2/50
10/10 - 0s - loss: 0.1567 - val_loss: 0.2499 - 430ms/epoch - 43ms/step
Epoch 3/50
10/10 - 0s - loss: 0.0298 - val_loss: 0.1968 - 424ms/epoch - 42ms/step
Epoch 4/50
10/10 - 0s - loss: 0.0204 - val_loss: 0.1874 - 428ms/epoch - 43ms/step
Epoch 5/50
10/10 - 0s - loss: 0.0214 - val_loss: 0.1987 - 437ms/epoch - 44ms/step
Epoch 6/50
10/10 - 0s - loss: 0.0148 - val_loss: 0.2125 - 422ms/epoch - 42ms/step
Epoch 7/50
10/10 - 0s - loss: 0.0119 - val_loss: 0.2148 - 415ms/epoch - 41ms/step
Epoch 8/50
10/10 - 0s - loss: 0.0110 - val_loss: 0.2072 - 422ms/epoch - 42ms/step
Epoch 9/50
10/10 - 0s - loss: 0.0100 - val_loss: 0.1989 - 413ms/epoch - 41ms/step
Epoch 10/50
10/10 - 0s - loss: 0.0093 - val_loss: 0.1945 - 426ms/epoch - 43ms/step
Epoch 11/50
10/10 - 0s - loss: 0.0088 - val_loss: 0.1934 - 456ms/epoch - 46ms/step
Epoch 12/50
10/10 - 0s - loss: 0.0083 - val_loss: 0.1927 - 448ms/epoch - 45ms/step
Epoch 13/50
10/10 - 0s - loss: 0.0079 - val_loss: 0.1911 - 455ms/epoch - 45ms/step
Epoch 14/50
10/10 - 0s - loss: 0.0076 - val_loss: 0.1888 - 451ms/epoch - 45ms/step
Epoch 15/50
10/10 - 0s - loss: 0.0073 - val_loss: 0.1863 - 470ms/epoch - 47ms/step
Epoch 16/50
10/10 - 0s - loss: 0.0070 - val_loss: 0.1841 - 465ms/epoch - 46ms/step
Epoch 17/50
10/10 - 0s - loss: 0.0067 - val_loss: 0.1819 - 475ms/epoch - 48ms/step
Epoch 18/50
10/10 - 0s - loss: 0.0065 - val_loss: 0.1797 - 477ms/epoch - 48ms/step
Epoch 19/50
10/10 - 0s - loss: 0.0063 - val_loss: 0.1776 - 474ms/epoch - 47ms/step
Epoch 20/50
10/10 - 0s - loss: 0.0061 - val_loss: 0.1755 - 470ms/epoch - 47ms/step
Epoch 21/50
10/10 - 0s - loss: 0.0059 - val_loss: 0.1735 - 478ms/epoch - 48ms/step
Epoch 22/50
10/10 - 0s - loss: 0.0057 - val_loss: 0.1716 - 473ms/epoch - 47ms/step
Epoch 23/50
10/10 - 0s - loss: 0.0055 - val_loss: 0.1697 - 454ms/epoch - 45ms/step
Epoch 24/50
10/10 - 0s - loss: 0.0054 - val_loss: 0.1679 - 463ms/epoch - 46ms/step
Epoch 25/50
10/10 - 0s - loss: 0.0053 - val_loss: 0.1661 - 457ms/epoch - 46ms/step
Epoch 26/50
10/10 - 0s - loss: 0.0051 - val_loss: 0.1644 - 447ms/epoch - 45ms/step
Epoch 27/50
10/10 - 0s - loss: 0.0050 - val_loss: 0.1628 - 467ms/epoch - 47ms/step
Epoch 28/50
10/10 - 0s - loss: 0.0049 - val_loss: 0.1612 - 466ms/epoch - 47ms/step
Epoch 29/50
10/10 - 0s - loss: 0.0048 - val_loss: 0.1597 - 464ms/epoch - 46ms/step
Epoch 30/50
10/10 - 0s - loss: 0.0047 - val_loss: 0.1582 - 486ms/epoch - 49ms/step
Epoch 31/50
10/10 - 1s - loss: 0.0046 - val_loss: 0.1568 - 501ms/epoch - 50ms/step
Epoch 32/50
10/10 - 0s - loss: 0.0045 - val_loss: 0.1554 - 497ms/epoch - 50ms/step
Epoch 33/50
10/10 - 0s - loss: 0.0044 - val_loss: 0.1541 - 477ms/epoch - 48ms/step
Epoch 34/50
10/10 - 1s - loss: 0.0043 - val_loss: 0.1528 - 501ms/epoch - 50ms/step
Epoch 35/50
10/10 - 0s - loss: 0.0042 - val_loss: 0.1516 - 490ms/epoch - 49ms/step
Epoch 36/50
10/10 - 0s - loss: 0.0041 - val_loss: 0.1504 - 494ms/epoch - 49ms/step
Epoch 37/50
10/10 - 0s - loss: 0.0040 - val_loss: 0.1492 - 484ms/epoch - 48ms/step
Epoch 38/50
10/10 - 0s - loss: 0.0040 - val_loss: 0.1481 - 460ms/epoch - 46ms/step
Epoch 39/50
10/10 - 0s - loss: 0.0039 - val_loss: 0.1470 - 467ms/epoch - 47ms/step
Epoch 40/50
10/10 - 0s - loss: 0.0038 - val_loss: 0.1460 - 464ms/epoch - 46ms/step
Epoch 41/50
10/10 - 0s - loss: 0.0038 - val_loss: 0.1450 - 456ms/epoch - 46ms/step
Epoch 42/50
10/10 - 0s - loss: 0.0037 - val_loss: 0.1440 - 465ms/epoch - 47ms/step
Epoch 43/50
10/10 - 0s - loss: 0.0036 - val_loss: 0.1430 - 477ms/epoch - 48ms/step
Epoch 44/50
10/10 - 1s - loss: 0.0036 - val_loss: 0.1421 - 512ms/epoch - 51ms/step
Epoch 45/50
10/10 - 1s - loss: 0.0035 - val_loss: 0.1412 - 511ms/epoch - 51ms/step
Epoch 46/50
10/10 - 1s - loss: 0.0034 - val_loss: 0.1403 - 527ms/epoch - 53ms/step
Epoch 47/50
10/10 - 1s - loss: 0.0034 - val_loss: 0.1394 - 512ms/epoch - 51ms/step
Epoch 48/50
10/10 - 1s - loss: 0.0033 - val_loss: 0.1386 - 515ms/epoch - 52ms/step
Epoch 49/50
10/10 - 1s - loss: 0.0033 - val_loss: 0.1378 - 514ms/epoch - 51ms/step
Epoch 50/50
10/10 - 1s - loss: 0.0032 - val_loss: 0.1370 - 520ms/epoch - 52ms/step
Model: "sequential"
_________________________________________________________________
 Layer (type)                Output Shape              Param #
=================================================================
 gru (GRU)                   (None, 30, 128)           66432

 gru_1 (GRU)                 (None, 64)                37248

 dense (Dense)               (None, 32)                2080

 dense_1 (Dense)             (None, 3)                 99

=================================================================
Total params: 105,859
Trainable params: 105,859
Non-trainable params: 0
_________________________________________________________________
None
Price Prediction Accuracy is 0.5474391267842149
----- Train_RMSE_GRU ----- 933.7005315858607
Price Prediction Accuracy is 0.5192697768762677
----- Val_RMSE_GRU ----- 2719.129655323418
Price Prediction Accuracy is 0.5166666666666667
----- Test_RMSE_GRU ----- 1645.4244144705867
input_dim: 30, feature_size: 43, output_dim: 3
/Users/simon/miniconda3/envs/algo_trading/lib/python3.10/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.
  super(Adam, self).__init__(name, **kwargs)
Epoch 1/50
19/19 - 3s - loss: 0.1546 - val_loss: 0.4364 - 3s/epoch - 138ms/step
Epoch 2/50
19/19 - 0s - loss: 0.4874 - val_loss: 1.0332 - 430ms/epoch - 23ms/step
Epoch 3/50
19/19 - 0s - loss: 0.4121 - val_loss: 1.0679 - 431ms/epoch - 23ms/step
Epoch 4/50
19/19 - 0s - loss: 0.5075 - val_loss: 1.5903 - 445ms/epoch - 23ms/step
Epoch 5/50
19/19 - 0s - loss: 0.5239 - val_loss: 0.8558 - 429ms/epoch - 23ms/step
Epoch 6/50
19/19 - 0s - loss: 0.2352 - val_loss: 0.3206 - 421ms/epoch - 22ms/step
Epoch 7/50
19/19 - 0s - loss: 0.0817 - val_loss: 0.1915 - 426ms/epoch - 22ms/step
Epoch 8/50
19/19 - 0s - loss: 0.0315 - val_loss: 0.2498 - 426ms/epoch - 22ms/step
Epoch 9/50
19/19 - 0s - loss: 0.0169 - val_loss: 0.1541 - 426ms/epoch - 22ms/step
Epoch 10/50
19/19 - 0s - loss: 0.0102 - val_loss: 0.1389 - 419ms/epoch - 22ms/step
Epoch 11/50
19/19 - 0s - loss: 0.0086 - val_loss: 0.1547 - 433ms/epoch - 23ms/step
Epoch 12/50
19/19 - 0s - loss: 0.0061 - val_loss: 0.1466 - 417ms/epoch - 22ms/step
Epoch 13/50
19/19 - 0s - loss: 0.0052 - val_loss: 0.1527 - 443ms/epoch - 23ms/step
Epoch 14/50
19/19 - 0s - loss: 0.0043 - val_loss: 0.1528 - 429ms/epoch - 23ms/step
Epoch 15/50
19/19 - 0s - loss: 0.0039 - val_loss: 0.1525 - 429ms/epoch - 23ms/step
Epoch 16/50
19/19 - 0s - loss: 0.0036 - val_loss: 0.1579 - 426ms/epoch - 22ms/step
Epoch 17/50
19/19 - 0s - loss: 0.0036 - val_loss: 0.1548 - 426ms/epoch - 22ms/step
Epoch 18/50
19/19 - 0s - loss: 0.0036 - val_loss: 0.1622 - 418ms/epoch - 22ms/step
Epoch 19/50
19/19 - 0s - loss: 0.0043 - val_loss: 0.1627 - 424ms/epoch - 22ms/step
Epoch 20/50
19/19 - 0s - loss: 0.0060 - val_loss: 0.1727 - 423ms/epoch - 22ms/step
Epoch 21/50
19/19 - 0s - loss: 0.0100 - val_loss: 0.1874 - 426ms/epoch - 22ms/step
Epoch 22/50
19/19 - 0s - loss: 0.0183 - val_loss: 0.2170 - 426ms/epoch - 22ms/step
Epoch 23/50
19/19 - 0s - loss: 0.0266 - val_loss: 0.2655 - 426ms/epoch - 22ms/step
Epoch 24/50
19/19 - 0s - loss: 0.0317 - val_loss: 0.2298 - 426ms/epoch - 22ms/step
Epoch 25/50
19/19 - 0s - loss: 0.0307 - val_loss: 0.2343 - 421ms/epoch - 22ms/step
Epoch 26/50
19/19 - 0s - loss: 0.0148 - val_loss: 0.1549 - 428ms/epoch - 23ms/step
Epoch 27/50
19/19 - 0s - loss: 0.0087 - val_loss: 0.1639 - 424ms/epoch - 22ms/step
Epoch 28/50
19/19 - 0s - loss: 0.0049 - val_loss: 0.2232 - 431ms/epoch - 23ms/step
Epoch 29/50
19/19 - 0s - loss: 0.0066 - val_loss: 0.1515 - 426ms/epoch - 22ms/step
Epoch 30/50
19/19 - 0s - loss: 0.0070 - val_loss: 0.1931 - 426ms/epoch - 22ms/step
Epoch 31/50
19/19 - 0s - loss: 0.0038 - val_loss: 0.2061 - 427ms/epoch - 22ms/step
Epoch 32/50
19/19 - 0s - loss: 0.0039 - val_loss: 0.1630 - 425ms/epoch - 22ms/step
Epoch 33/50
19/19 - 0s - loss: 0.0052 - val_loss: 0.2107 - 417ms/epoch - 22ms/step
Epoch 34/50
19/19 - 0s - loss: 0.0038 - val_loss: 0.2003 - 426ms/epoch - 22ms/step
Epoch 35/50
19/19 - 0s - loss: 0.0031 - val_loss: 0.1707 - 421ms/epoch - 22ms/step
Epoch 36/50
19/19 - 0s - loss: 0.0040 - val_loss: 0.2237 - 426ms/epoch - 22ms/step
Epoch 37/50
19/19 - 0s - loss: 0.0037 - val_loss: 0.1998 - 425ms/epoch - 22ms/step
Epoch 38/50
19/19 - 0s - loss: 0.0033 - val_loss: 0.1789 - 422ms/epoch - 22ms/step
Epoch 39/50
19/19 - 0s - loss: 0.0046 - val_loss: 0.2387 - 426ms/epoch - 22ms/step
Epoch 40/50
19/19 - 0s - loss: 0.0045 - val_loss: 0.2036 - 425ms/epoch - 22ms/step
Epoch 41/50
19/19 - 0s - loss: 0.0035 - val_loss: 0.1765 - 422ms/epoch - 22ms/step
Epoch 42/50
19/19 - 0s - loss: 0.0048 - val_loss: 0.2573 - 427ms/epoch - 22ms/step
Epoch 43/50
19/19 - 0s - loss: 0.0054 - val_loss: 0.2080 - 430ms/epoch - 23ms/step
Epoch 44/50
19/19 - 0s - loss: 0.0064 - val_loss: 0.1845 - 426ms/epoch - 22ms/step
Epoch 45/50
19/19 - 0s - loss: 0.0134 - val_loss: 0.3090 - 423ms/epoch - 22ms/step
Epoch 46/50
19/19 - 0s - loss: 0.0172 - val_loss: 0.2243 - 424ms/epoch - 22ms/step
Epoch 47/50
19/19 - 0s - loss: 0.0126 - val_loss: 0.1679 - 429ms/epoch - 23ms/step
Epoch 48/50
19/19 - 0s - loss: 0.0093 - val_loss: 0.2849 - 426ms/epoch - 22ms/step
Epoch 49/50
19/19 - 0s - loss: 0.0089 - val_loss: 0.2460 - 427ms/epoch - 22ms/step
Epoch 50/50
19/19 - 0s - loss: 0.0124 - val_loss: 0.1579 - 421ms/epoch - 22ms/step
Model: "sequential_1"
_________________________________________________________________
 Layer (type)                Output Shape              Param #
=================================================================
 bidirectional (Bidirectiona  (None, 256)              176128
 l)

 dense_2 (Dense)             (None, 64)                16448

 dense_3 (Dense)             (None, 3)                 195

=================================================================
Total params: 192,771
Trainable params: 192,771
Non-trainable params: 0
_________________________________________________________________
None
Price Prediction Accuracy is 0.5667506297229219
----- Train_RMSE_LSTM ----- 933.670582991969
Price Prediction Accuracy is 0.5111561866125761
----- Val_RMSE_LSTM ----- 2719.4548899645115
Price Prediction Accuracy is 0.5166666666666667
----- Test_RMSE_LSTM ----- 1646.4616629792254
Running Basic Gan with the following configs: 30_3, 165, 128, 0.00016
output dimension is 3
WARNING:tensorflow:Layer gru_2 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_3 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_4 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
/Users/simon/miniconda3/envs/algo_trading/lib/python3.10/site-packages/keras/optimizers/optimizer_v2/adam.py:110: UserWarning: The `lr` argument is deprecated, use `learning_rate` instead.
  super(Adam, self).__init__(name, **kwargs)
/Users/simon/miniconda3/envs/algo_trading/lib/python3.10/site-packages/tensorflow/python/util/dispatch.py:1082: UserWarning: "`binary_crossentropy` received `from_logits=True`, but the `output` argument was produced by a sigmoid or softmax activation and thus does not represent logits. Was this intended?"
  return dispatch_target(*args, **kwargs)
epoch 15 d_loss 1.3262063 g_loss 0.72226876
epoch 30 d_loss 1.3769293 g_loss 0.6859909
epoch 45 d_loss 1.3804975 g_loss 0.7068118
epoch 60 d_loss 1.3856584 g_loss 0.68968755
epoch 75 d_loss 1.3864256 g_loss 0.6967365
epoch 90 d_loss 1.3862143 g_loss 0.6949338
epoch 105 d_loss 1.3862696 g_loss 0.69571316
epoch 120 d_loss 1.3861773 g_loss 0.6934499
epoch 135 d_loss 1.3856945 g_loss 0.69345045
epoch 150 d_loss 1.3862426 g_loss 0.69414836
epoch 165 d_loss 1.3858852 g_loss 0.6964618
WARNING:tensorflow:Compiled the loaded model, but the compiled metrics have yet to be built. `model.compile_metrics` will be empty until you train or evaluate the model.
pred_price length: 165, real price length: 1256
(1256,)
[-0.10276023 -0.1536296  -0.11771184 ... -0.10746693 -0.0602039
 -0.09815691]
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:33: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df[f'pred_price_{i}'] = y_scaler.inverse_transform(pred_price[i].reshape(-1, 1))
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_Basic_GAN.py:35: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  price_df['real_price'] = y_scaler.inverse_transform(real_price.reshape(-1, 1))
price_df shape: (1256, 166)
WARNING:tensorflow:Layer gru_2 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_3 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_4 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:No training configuration found in the save file, so the model was *not* compiled. Compile it manually.
Price Prediction Accuracy is 0.5134615384615384
WARNING:tensorflow:Layer gru_5 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_6 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
epoch 15 d_loss 7.64833 g_loss 0.006865753
epoch 30 d_loss 5.2730503 g_loss -0.0010206687
epoch 45 d_loss 2.6618476 g_loss -0.019534685
epoch 60 d_loss 0.5576956 g_loss 0.11767198
epoch 75 d_loss 0.21364874 g_loss 0.0036640198
epoch 90 d_loss 0.11409393 g_loss -0.023728617
WARNING:tensorflow:Compiled the loaded model, but the compiled metrics have yet to be built. `model.compile_metrics` will be empty until you train or evaluate the model.
/Users/simon/PycharmProjects/ML-in-Practice-New-Repo-main/model_WGAN_GP.py:33: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

WARNING:tensorflow:Layer gru_5 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:Layer gru_6 will not use cuDNN kernels since it doesn't meet the criteria. It will use a generic GPU kernel as fallback when running on GPU.
WARNING:tensorflow:No training configuration found in the save file, so the model was *not* compiled. Compile it manually.
Price Prediction Accuracy is 0.5115384615384615

Process finished with exit code 0
